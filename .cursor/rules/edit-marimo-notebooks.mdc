---
description: Use this rule when asked to create or edit a marimo notebook in this repo
alwaysApply: false
---

## Notebook Structure and Cell Organization
- **Setup Cell**: always start with the `setup_pyoso` cell (exact logic below)
- **Documentation Cell(s)**:  
  - Title, description, author, and last updated date
  - Accordion with methodology, data sources, and resources
- **Configuration Cell**: constants, layouts, reusable configs
- **Data Cells**: fetch and process data in dedicated cells
- **Visualization Cells**: group related charts together; keep clean separation
- **UI Cells**: isolate user inputs; consume `.value` explicitly

---

## Setup Cell Pattern
Every Marimo notebook MUST begin with the following exact cell:

```python
@app.cell
def setup_pyoso():
    # This code sets up pyoso to be used as a database provider for this notebook
    # This code is autogenerated. Modification could lead to unexpected results :)
    import marimo as mo
    from pyoso import Client
    client = Client()
    try:
        pyoso_db_conn = client.dbapi_connection()    
    except Exception as e:
        pyoso_db_conn = None
    return mo, client, pyoso_db_conn
```

---

## Documentation Pattern
Each app must include a title and description. Use **"OSO Team"** for the author by default and the current date for the last updated date.

```python
@app.cell
def _(mo):
    mo.md(
        """
        # App Title
        <small>Author: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">OSO Team</span> · Last Updated: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">[Date]</span></small>

        Brief description of what this app does.
        """
    )
    return
```

Each app must also include an accordion with methodology, data sources, and further resources:

```python
@app.cell
def _(mo):
    mo.accordion({
        "Methodology": """
        - Explanation of how the app works
        - Key definitions and metrics
        - Data processing approach
        - Important caveats or limitations
        """,
        "Data Sources": """
        - Project registries (with links)
        - Event data sources (with links)
        - Spreadsheets / connectors / static files
        - Any other external data sources
        """,
        "Further Resources": """
        - [Getting Started with Pyoso](https://docs.opensource.observer/docs/get-started/python)
        - [Using the Semantic Layer](https://docs.opensource.observer/docs/get-started/using-semantic-layer)
        - [Marimo Documentation](https://docs.marimo.io/)
        """
    })
    return
```

---

## Imports
- Group imports: stdlib → third-party → project-specific
- Keep imports minimal in each cell

```python
import pandas as pd
import numpy as np
import plotly.express as px
```

---

## UI Components
- Use `mo.ui.*` for dropdowns, multiselects, sliders, checkboxes, and buttons
- Widget variables end with `_input`; consume `.value` downstream
- Organize with `mo.hstack()` and `mo.vstack()`
- For simple inputs, show directly; for grouped controls, wrap in `mo.vstack()`

```python
# Simple widget
project_input = mo.ui.dropdown(...)
project_input
return (project_input,)

# With header
mo.vstack([
    mo.md("### Configuration"),
    project_input
])
return (project_input,)
```

- Gate expensive operations with a button:  
  ```python
  run_analysis_input = mo.ui.run_button()
  run_analysis_input
  ```
- And then use it to gate expensive operations:
  ```python
  mo.stop(not run_analysis_input.value)
  # Your expensive operation here
  ```

---

## Cell Dependencies and Return Patterns
- Always `return` variables that will be used in other cells
- Use `return (var,)` for single and `return (var1, var2)` for multiple
- Do **not** use `_` prefix for returned variables (they must be usable by other cells)
- UI cells must always return widget variables

```python
# Data processing
@app.cell
def _(client, project_input):
    _query = f"SELECT * FROM table WHERE id = '{project_input.value}'"
    df_data = client.to_pandas(_query)
    return (df_data,)

# UI cell
@app.cell
def _(mo):
    project_input = mo.ui.dropdown(...)
    mo.vstack([project_input])
    return (project_input,)
```

---

## State Management
- Avoid `mo.state` unless persistence or synchronization is truly required
- Prefer explicit value-driven reactivity

---

## Visualization Standards
- Use Plotly as the default charting library
- Always sort by x-axis before plotting
- Apply a shared styling helper:

```python
def make_fig(dataframe, title=""):
    fig = px.line(
        dataframe,
        x="sample_date",
        y=dataframe.columns[1:],
        title=f"<b>{title}</b>"
    )
    fig.update_layout(
        paper_bgcolor="white",
        plot_bgcolor="white",
        font=dict(size=12, color="#111"),
        title=dict(text=title, x=0, xanchor="left"),
        margin=dict(t=50, l=20, r=20, b=20),
        legend_title="",
        hovermode="x"
    )
    fig.update_xaxes(showgrid=False, linecolor="#000", ticks="outside")
    fig.update_yaxes(showgrid=True, gridcolor="#DDD", linecolor="#000", ticks="outside")
    return fig

_fig = make_fig(_df, "Title")
mo.ui.plotly(_fig)
```

- Use consistent color palettes
- Titles left-aligned; legends concise
- Avoid secondary y-axes
- Format hover templates for readability

---

### Data Tables
- Use `mo.ui.table()` for interactive display
- Include `format_mapping` for numbers/dates
- Set `page_size` appropriately (default 50)
- Disable unused features: `show_data_types=False`, `show_column_summaries=False`
- Clean column names and sort before display
- Wrap in `mo.vstack()` with section headers

---

## Data Processing
- Use pandas method chaining and descriptive names
- Handle dates with `pd.to_datetime()`
- Keep transformations in dedicated cells
- Variables:
  - DataFrames across cells: normal names (`df_projects`)
  - Local variables inside cells: `_` prefix (`_query`, `_result`)
  - Widgets: `_input` suffix (`project_name_input`)
- **Never** use `_` prefix for variables that must be returned between cells

---

## SQL Queries (Trino)
- Dialect: **Trino**
- Indent: **2 spaces**
- One variable per line in `SELECT` and CTEs
- No padding mid-line
- No trailing semicolons
- Use CTEs for readability
- Comment complex logic
- Write queries in one of two approved patterns:

```python
# Option 1: mo.sql
_query = f"""
  SELECT
    created_at,
    updated_at,
    artifact_id
  FROM repositories_v0
"""
_df = mo.sql(
    _query,
    engine=pyoso_db_conn
)

# Option 2: client.to_pandas
_query = f"""
  SELECT
    created_at,
    updated_at,
    artifact_id
  FROM repositories_v0
"""
_df = client.to_pandas(_query)
```

---

## Error Handling and Robustness
- Keep error handling simple and minimal
- Prefer clean, direct flows over defensive programming
- Surface concise error messages with `mo.md()`

---

## Performance
- Fetch only necessary data ranges
- Cache expensive computations in separate cells
- Use efficient pandas operations
- Avoid rendering very large tables; paginate or sample instead

---

## Code Style
- Python: 4 spaces (PEP 8)
- SQL: 2 spaces
- Descriptive names: `*_input` (widgets), `fig_*` (plots), `_var` (locals)
- Global constants: `UPPER_CASE`
- Functions: focused, typed, and reusable
- Consistent formatting across cells

---

## Documentation
- Markdown for context; concise and data-driven
- Inline comments for complex logic

---

## Workflow
1. Define objective
2. Setup → documentation
3. Data connections
4. Fetch and validate data
5. Create UI components
6. Build visualizations
7. Add markdown + accordion documentation
8. Test interactivity and error handling

---

## Anti-Patterns
- Hardcoding values that should be configurable
- Mixing data processing and visualization in the same cell
- Using widget objects directly in expressions (instead of `.value`)
- Returning `_`-prefixed variables (breaks dependencies)
- Overly complex single cells
- Inconsistent styling across visualizations
- Complex conditional UI rendering
- Over-engineering error handling