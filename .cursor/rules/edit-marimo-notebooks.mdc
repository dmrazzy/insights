---
description: Use this rule when asked to create or edit a marimo notebook in this repo
alwaysApply: false
---
## Notebook Structure and Cell Organization
- **Setup Cell**: always start with the `setup_pyoso` cell (exact logic below)
- **Documentation Cell(s)**:  
  - Title, description, author, and last updated date  
  - Accordion with implementation notes, data sources, and resources
- **Configuration Cell**: constants, layouts, reusable configs
- **Data Cells**: fetch and process data in dedicated cells
- **Visualization Cells**: group related charts together; keep clean separation
- **UI Cells**: isolate user inputs; consume `.value` explicitly

---

## Setup Cell Pattern
Every Marimo notebook MUST begin with the following exact cell:

```python
@app.cell
def setup_pyoso():
    # This code sets up pyoso to be used as a database provider for this notebook
    # This code is autogenerated. Modification could lead to unexpected results :)
    import marimo as mo
    from pyoso import Client
    client = Client()
    try:
        pyoso_db_conn = client.dbapi_connection()    
    except Exception as e:
        pyoso_db_conn = None
    return mo, client, pyoso_db_conn
```

---

## Documentation Pattern
Each app must include:

```python
@app.cell
def _(mo):
    mo.md(
        """
        # App Title

        Brief description of what this app does.

        **Author:** [Name]  
        **Last Updated:** [Date]
        """
    )
    return
```

```python
@app.cell
def _(mo):
    mo.accordion({
        "How is this app implemented?": """
        - Brief explanation
        - Methodology details
        - Caveats or limitations
        """,
        "Data Sources": """
        - Project registries (and links)
        - Event data sources (and links)
        - Spreadsheets / private data connectors / static files
        - Any other external data sources (and links)
        """,
        "Resources": """
        - [Getting Started with Pyoso](https://docs.opensource.observer/docs/get-started/python)
        - [Using the Semantic Layer](https://docs.opensource.observer/docs/get-started/using-semantic-layer)
        - [Marimo Documentation](https://docs.marimo.io/)
        """
    })
    return
```

---

## Imports
- Grouped: stdlib → third-party → project-specific
- Keep imports minimal in each cell
- Example:

```python
import pandas as pd
import numpy as np
import plotly.express as px
```

---

## UI Components
- Prefer `mo.ui.*` for dropdowns, multiselects, sliders, checkboxes, buttons
- Widgets named with `_input` suffix; values consumed explicitly via `.value`
- Organize with `mo.hstack()` and `mo.vstack()`
- Gate expensive operations with a **button trigger**:

```python
_run_btn = mo.ui.button(label="Run Analysis")
_run_btn
```

Then use mo.stop() to gate expensive operations:

```python
mo.stop(not _run_btn.value, "Click 'Run Analysis' to proceed")
# ... expensive operations here
```

---

## Cell Dependencies and Return Patterns
- **Always return variables that need to be used in other cells**
- **Use consistent return patterns**: `return (variable,)` for single variables, `return (var1, var2)` for multiple
- **Never use `_` prefix for returned variables** - they become cell dependencies
- **UI cells should always return widget variables** for use in data processing cells

### Example Patterns:
```python
# Data processing cell
@app.cell
def _(client, project_input):
    query = f"SELECT * FROM table WHERE id = '{project_input.value}'"
    df_data = client.to_pandas(query)
    return (df_data,)  # ✅ Correct - no _ prefix

# UI cell  
@app.cell
def _(mo):
    project_input = mo.ui.dropdown(...)
    mo.vstack([project_input])
    return (project_input,)  # ✅ Correct - widget returned for other cells
```

---

## State Management
- **Avoid `mo.state`** unless persistence or synchronization is unavoidable
- Prefer value-driven reactivity and explicit flows

---

## Visualization Standards
- Use **Plotly-first** for charts
- Always sort by x-axis before plotting
- Apply a shared layout/style helper:

```python
def make_fig(dataframe, title=""):
    fig = px.line(
        dataframe,
        x='sample_date',
        y=dataframe.columns[1:],
        title=f'<b>{title}</b>',
    )
    fig.update_layout(
        paper_bgcolor="white",
        plot_bgcolor="white",
        font=dict(size=12, color="#111"),
        title=dict(text=title, x=0, xanchor="left"),
        margin=dict(t=50, l=20, r=20, b=20),
        legend_title="",
        hovermode="x"
    )
    fig.update_xaxes(showgrid=False, linecolor="#000", ticks="outside")
    fig.update_yaxes(showgrid=True, gridcolor="#DDD", linecolor="#000", ticks="outside")
    return fig

_fig = make_fig(_df, "Title")
mo.ui.plotly(_fig)
```

- Use stable categorical color palettes
- Titles always left-aligned; legends concise
- Avoid secondary y-axes — facet or annotate instead
- Format hover templates for clarity

---

### Data Tables
- Use `mo.ui.table()` for interactive data display
- Always include `format_mapping` for proper number/currency formatting
- Set appropriate `page_size` (default 50, adjust based on data size)
- Disable unnecessary features: `show_data_types=False`, `show_column_summaries=False`
- Sort data before display: `.sort_values(column, ascending=False).reset_index(drop=True)`
- Clean up column names with `.rename(columns={...})` (title case, remove underscores)

Example:

```python
mo.ui.table(
    _df_leaderboard.sort_values('Superchain TVL', ascending=False).reset_index(drop=True),
    format_mapping={
        'Current TVL': '${:,.0f}',
        'Superchain TVL': '${:,.0f}',
        'Share of TVL on Superchain': '{:.1%}',
        'GovGrants Funding': '${:,.0f}',
        'Retro Funding': '${:,.0f}',
        'Total Funding': '${:,.0f}',
    },
    show_data_types=False,
    show_column_summaries=False,
    page_size=50
)
```

---

## Data Processing
- Use pandas method chaining and descriptive variable names
- Handle dates with `pd.to_datetime()`
- Validate data before plotting (check nulls, row counts)
- Group transformations in dedicated cells

### Variable Naming Rules
- **DataFrames passed between cells**: Use normal names (e.g., `df_projects`, `df_timeseries`)
- **Local variables within cells**: Use `_` prefix (e.g., `_query`, `_result`, `_fig`)
- **Widget variables**: Use `_input` suffix (e.g., `project_name_input`)
- **Error variables**: Use descriptive names (e.g., `error_message`, `timeseries_error`)

**CRITICAL**: Never use `_` prefix for variables that need to be passed between cells via return statements.

---

## SQL Queries (Trino)
- **Dialect**: Trino
- **Indentation**: 2 spaces
- **One variable per line** in `SELECT` and CTEs
- **No spacing mid-line** (avoid padded expressions)
- **No trailing semicolons**
- Use CTEs for readability
- Comment complex logic
- Queries must be written in Python as one of two approved patterns:

### Option 1: Using `mo.sql`
```python
_query = f"""
  SELECT
    created_at,
    updated_at,
    artifact_id
  FROM repositories_v0
"""
_df = mo.sql(
    _query,
    engine=pyoso_db_conn
)
```

### Option 2: Using `client.to_pandas`
```python
_query = f"""
  SELECT
    created_at,
    updated_at,
    artifact_id
  FROM repositories_v0
"""
_df = client.to_pandas(_query)
```

---

## Error Handling and Robustness
- Wrap API calls in try/except
- Handle missing data with `.fillna()` or `.dropna()`
- Provide fallback defaults for UI widgets
- Surface clear, user-friendly error messages in UI cells with `mo.md()`

### Error Handling Patterns
**DO NOT** block UI rendering with conditional logic. Instead:

```python
# ❌ BAD - Blocks UI rendering
@app.cell
def _(df_projects, mo):
    if df_projects is None:
        mo.md("Error message")
        return  # This prevents UI from rendering
    # UI code here

# ✅ GOOD - UI always renders
@app.cell
def _(df_projects, mo):
    project_input = mo.ui.dropdown(...)  # Always creates widget
    
    components = [mo.md("### Title")]
    if df_projects is None:
        components.append(mo.md("Error message"))
    components.append(project_input)
    
    mo.vstack(components)
    return (project_input,)
```

**Key Principles**:
- UI components should always render regardless of data state
- Error messages should be displayed conditionally within the UI stack
- Use `mo.vstack()` or `mo.hstack()` to organize conditional content
- Never use early returns that prevent UI components from being created

---

## Performance
- Fetch only necessary data ranges
- Cache expensive computations in dedicated cells
- Use efficient pandas operations
- Avoid rendering very large tables; paginate or sample instead

---

## Code Style
- Python code: **4 space indentation** (PEP 8)
- SQL code: **2 space indentation**
- Descriptive names: `*_input` for widgets, `fig_*` for plots, `_var` for locals
- Global constants: `UPPER_CASE`
- Functions are focused, typed, and reusable
- Consistent indentation and formatting

---

## Documentation
- Markdown for context; concise and data-driven
- Use inline comments for complex logic

---

## Workflow
1. Define objective
2. Setup → documentation
3. Data connections
4. Fetch and validate data
5. Create UI components
6. Build styled visualizations
7. Add markdown + accordion documentation
8. Test interactivity and error handling

---

## Anti-Patterns
- Hardcoding values that should be configurable
- Mixing processing and visualization in the same cell
- Using widget objects directly in expressions (instead of `.value`)
- Forgetting `_` prefix for local variables
- Overly complex single cells
- Skipping error handling for APIs
- Inconsistent visualization styling
- **Using `_` prefix for variables passed between cells** (breaks cell dependencies)
- **Blocking UI rendering with conditional logic** (prevents widgets from appearing)
- **Early returns in UI cells** (stops widget creation)
- **Complex error handling that prevents UI components from rendering**
