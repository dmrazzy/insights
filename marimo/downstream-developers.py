import marimo

__generated_with = "0.15.3"
app = marimo.App(width="full")


@app.cell
def setup_pyoso():
    # This code sets up pyoso to be used as a database provider for this notebook
    # This code is autogenerated. Modification could lead to unexpected results :)
    import marimo as mo
    from pyoso import Client
    client = Client()
    try:
        pyoso_db_conn = client.dbapi_connection()    
    except Exception as e:
        pyoso_db_conn = None
    return client, mo


@app.cell
def about_app(mo):
    mo.vstack([
        mo.md("""
        # Downstream Developers
        <small>Author: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">OSO Team</span> Â· Last Updated: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">2025-09-16</span></small>
        """),
        mo.md("""
        This app analyzes the "downstream developers" of a package maintainer. It identifies all projects that depend on packages maintained by a given GitHub org, and captures the number of full-time developers working on those projects.
        """),
        mo.accordion({
            "<b>Click to see details on how app was made</b>": mo.accordion({
                "Methodology": """
                The app uses the OSO API to query data about open-source projects. The analysis involves these steps:

                - **Identifying Dependents:** It queries the OSS Directory for projects that list the specified package as a dependency in their Software Bill of Materials (SBOM).
                - **Measuring Activity:** For each dependent project, it queries for the number of monthly active developers as of a specific snapshot date.

                The app generates two visualizations:

                - **Package Manager Distribution:** A bar chart shows the distribution of the package's downstream dependents by their package manager (e.g., Go Modules, NPM, etc.). This helps understand where the package is most commonly used.
                - **Downstream Developer Activity:** A bar chart ranks the dependent projects by their number of monthly active developers, highlighting the most active projects in the ecosystem.
                """,
                "Data Sources": """
                - [OSO Database](https://docs.opensource.observer/docs/get-started/python) - Open source project registry and metrics
                - [OSS Directory](https://oss-directory.com/) - Project registry with dependency information
                - GitHub - Repository and developer activity data
                """,
                "Further Resources": """
                - [Getting Started with Pyoso](https://docs.opensource.observer/docs/get-started/python)
                - [Using the Semantic Layer](https://docs.opensource.observer/docs/get-started/using-semantic-layer)
                - [Marimo Documentation](https://docs.marimo.io/)
                """
            })
        })    
    ])
    return


@app.cell
def configuration_settings(mo):
    package_owner = mo.ui.text(
        value="libp2p",
        label="Package Owner"
    )

    project_registry = mo.ui.dropdown(
        value="OSS_DIRECTORY",
        options=['OSS_DIRECTORY', 'CRYPTO_ECOSYSTEMS'],
        label="Project Registry"
    )

    snapshot_date_input = mo.ui.text(
        value="2025-08-01",
        label="Snapshot Date (YYYY-MM-DD)"
    )

    mo.vstack([
        mo.md("### Configuration"),
        package_owner,
        project_registry,
        snapshot_date_input
    ])
    return package_owner, project_registry, snapshot_date_input


@app.cell
def get_dependents_data(client, package_owner, project_registry):
    _query = f"""
    WITH packages AS (
      SELECT package_artifact_id
      FROM package_owners_v0
      WHERE package_owner_artifact_namespace = '{package_owner.value}'
    )
    SELECT
      p.project_id,
      p.display_name AS project_name,
      sbom.package_artifact_source,
      array_join(ARRAY_AGG(DISTINCT CONCAT(abp.artifact_namespace, '/', abp.artifact_name)), '; ') AS repo
    FROM sboms_v0 AS sbom
    JOIN packages USING package_artifact_id
    JOIN artifacts_by_project_v1 AS abp
    ON
      abp.artifact_id = sbom.dependent_artifact_id
      AND abp.artifact_source = 'GITHUB'
      AND abp.project_source = '{project_registry.value}'
      AND abp.project_namespace IN ('oso', 'eco')
    JOIN projects_v1 AS p
      ON abp.project_id = p.project_id
    GROUP BY 1, 2, 3
    """

    df_dependents = client.to_pandas(_query)
    return (df_dependents,)


@app.cell
def get_developers_data(client, df_dependents, pd, snapshot_date_input):
    if len(df_dependents) == 0:
        df_developers = pd.DataFrame(columns=['project_id', 'project_name', 'downstream_developers'])
    else:
        project_ids = df_dependents['project_id'].unique()
        stringify = lambda arr: "'" + "','".join(arr) + "'"

        _query = f"""
        SELECT
          p.project_id,
          p.display_name AS project_name,
          SUM(tm.amount) AS downstream_developers
        FROM timeseries_metrics_by_project_v0 AS tm
        JOIN metrics_v0 USING metric_id
        JOIN projects_v1 AS p 
          ON p.project_id = tm.project_id
        WHERE
          tm.project_id IN ({stringify(project_ids)})
          AND metric_name = 'GITHUB_active_developers_monthly'
          AND sample_date = DATE('{snapshot_date_input.value}')
        GROUP BY 1,2
        ORDER BY 3 DESC
        """

        df_developers = client.to_pandas(_query)
    return (df_developers,)


@app.cell
def consolidate_data(df_dependents, df_developers, pd):
    if len(df_dependents) == 0:
        df_consolidated = pd.DataFrame(columns=['project_name', 'downstream_developers', 'repos_by_source'])
    else:
        base = (
            df_developers[['project_id','project_name','downstream_developers']]
            .merge(
                df_dependents[['project_id','package_artifact_source','repo']],
                on='project_id',
                how='left'
            )
            .drop_duplicates()
        )
        repos_by_source = (
            base
            .dropna(subset=['package_artifact_source','repo'])
            .assign(repo=lambda d: d['repo'].astype(str).str.split(';'))
            .explode('repo')
            .assign(repo=lambda d: d['repo'].str.strip())
            .query("repo != ''")
            .groupby(['project_id','project_name','package_artifact_source'], as_index=False)['repo']
            .agg(lambda s: '; '.join(sorted(s.dropna().unique())))
        )
        rolled = (
            repos_by_source
            .assign(source_blob=lambda d: d['package_artifact_source'].astype(str)+': '+d['repo'])
            .groupby(['project_id','project_name'], as_index=False)['source_blob']
            .agg(lambda s: '. '.join(s))
            .rename(columns={'source_blob':'repos_by_source'})
        )
        df_consolidated = (
            base[['project_id','project_name','downstream_developers']]
            .groupby(['project_id','project_name'], as_index=False)['downstream_developers']
            .max()
            .merge(rolled, on=['project_id','project_name'], how='left')
            .sort_values('downstream_developers', ascending=False)
            [['project_id','project_name','downstream_developers','repos_by_source']]
            .drop(columns=['project_id'])
            .reset_index(drop=True)
        )
    return (df_consolidated,)


@app.cell
def generate_stats(df_dependents, df_developers, mo):
    num_dependent_orgs = mo.stat(
        label="Dependent Projects",
        bordered=True,
        value=f"{len(df_dependents):,.0f}",
    )

    total_downstream_developers = df_developers['downstream_developers'].sum() if len(df_developers) > 0 else 0
    num_downstream_developers = mo.stat(
        label="Total Downstream Developers",
        bordered=True,
        value=f"{total_downstream_developers:,.0f}",
    )

    num_package_sources = df_dependents['package_artifact_source'].nunique() if len(df_dependents) > 0 else 0
    num_sources = mo.stat(
        label="Package Sources",
        bordered=True,
        value=f"{num_package_sources:,.0f}",
    )

    mo.hstack([num_dependent_orgs, num_downstream_developers, num_sources], widths="equal", gap=1)
    return


@app.cell
def generate_package_manager_plot(df_dependents, mo, package_owner, px):
    source_counts = df_dependents['package_artifact_source'].value_counts().reset_index()
    source_counts.columns = ['package_artifact_source', 'project_count']

    def make_bar_fig(dataframe, title=""):
        fig = px.bar(
            dataframe,
            x='project_count',
            y='package_artifact_source',
            orientation='h',
            title=f"<b>{title}</b>",
            labels={
                'package_artifact_source': 'Package Manager',
                'project_count': 'Number of Projects'
            },
            text='project_count'
        )
        fig.update_layout(
            paper_bgcolor="white",
            plot_bgcolor="white",
            font=dict(size=12, color="black"),
            title=dict(text=title, x=0, xanchor="left"),
            margin=dict(t=50, l=20, r=20, b=20),
            legend_title="",
            hovermode="x"
        )
        fig.update_traces(marker_color='black', textposition='outside')
        fig.update_yaxes(categoryorder="total ascending")
        return fig

    _fig = make_bar_fig(source_counts, f"{package_owner.value} usage by package manager")
    mo.ui.plotly(_fig)
    return


@app.cell
def generate_table(df_consolidated, mo):
    mo.ui.table(
        df_consolidated.reset_index(drop=True),
        selection=None,
        show_column_summaries=False,
        show_data_types=False,
        page_size=10
    )
    return


@app.cell
def generate_developers_histogram(df_developers, mo, package_owner, pd, px):
    def create_intelligent_bins(dataframe):
        if len(dataframe) == 0:
            return pd.DataFrame(columns=['bin_range', 'count'])

        def assign_bin(dev_count):
            if dev_count == 1:
                return "1"
            elif dev_count <= 3:
                return "2-3"
            elif dev_count <= 5:
                return "4-5"
            elif dev_count <= 10:
                return "6-10"
            elif dev_count <= 20:
                return "11-20"
            elif dev_count <= 40:
                return "21-40"
            else:
                return "40+"

        dataframe_with_bins = dataframe.copy()
        dataframe_with_bins['bin_range'] = dataframe_with_bins['downstream_developers'].apply(assign_bin)

        bin_counts = dataframe_with_bins['bin_range'].value_counts().reset_index()
        bin_counts.columns = ['bin_range', 'count']

        # Define the order for proper sorting
        bin_order = ["1", "2-3", "4-5", "6-10", "11-20", "21-40", "40+"]
        bin_counts['bin_range'] = pd.Categorical(bin_counts['bin_range'], categories=bin_order, ordered=True)
        bin_counts = bin_counts.sort_values('bin_range')

        return bin_counts

    def make_hist_fig(bin_dataframe, title=""):
        fig = px.bar(
            bin_dataframe,
            x='bin_range',
            y='count',
            title=f"<b>{title}</b>",
            labels={
                'bin_range': 'Number of Active Developers (Monthly)',
                'count': 'Number of Projects'
            },
            color_discrete_sequence=['black']
        )
        fig.update_layout(
            paper_bgcolor="white",
            plot_bgcolor="white",
            font=dict(size=12, color="#111"),
            title=dict(text=title, x=0, xanchor="left"),
            margin=dict(t=50, l=20, r=20, b=20),
            legend_title="",
            hovermode="x"
        )
        #fig.update_traces(text='count', textposition='outside')
        fig.update_xaxes(showgrid=False, linecolor="#000", ticks="outside")
        fig.update_yaxes(showgrid=True, gridcolor="#DDD", linecolor="#000", ticks="outside")
        return fig

    bin_data = create_intelligent_bins(df_developers)
    _fig = make_hist_fig(bin_data, f"Distribution of developer activity for projects using {package_owner.value}")
    mo.ui.plotly(_fig)
    return


@app.cell
def import_libraries():
    import pandas as pd
    import plotly.express as px
    return pd, px


if __name__ == "__main__":
    app.run()
