import marimo

__generated_with = "0.16.2"
app = marimo.App(width="full")


@app.cell
def setup_pyoso():
    # This code sets up pyoso to be used as a database provider for this notebook
    # This code is autogenerated. Modification could lead to unexpected results :)
    import marimo as mo
    from pyoso import Client
    client = Client()
    try:
        pyoso_db_conn = client.dbapi_connection()    
    except Exception as e:
        pyoso_db_conn = None
    return (mo,)


@app.cell
def about_app(mo):
    mo.vstack([
        mo.md("""
        # Gitcoin Grants Growth Analysis
        <small>Author: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">OSO Team</span> · Last Updated: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">2025-10-10</span></small>
        """),
        mo.md("""
        This dashboard analyzes the relationship between Gitcoin Grants funding and developer ecosystem growth from 2018-2023. 
        The analysis focuses on the top 50 OSS projects that received grants and tracks their quarterly developer metrics to demonstrate 
        how grants funding correlates with contributor growth, part-time developers, and full-time developers.
        """),
        mo.accordion({
            "<b>Click to see details on how app was made</b>": mo.accordion({
                "Methodology": """
                - Analyzes Gitcoin Grants funding data from GR1 (2019) through GG19 (2023)
                - Identifies the top 50 OSS projects by maximum contributor count
                - Tracks quarterly metrics: contributors, part-time developers, and full-time developers
                - Segments grants history into four phases based on program evolution
                - Calculates QF multipliers and ROI metrics for funded projects
                - Growth metrics are normalized to show multiples of initial values
                """,
                "Data Sources": """
                - [Gitcoin Grants Data (GitHub)](https://raw.githubusercontent.com/opensource-observer/insights/refs/heads/main/analysis/gitcoin/data)
                - OSS Developer Impact Metrics (active developers, contributors by quarter)
                - Project metadata and naming from OSS Directory
                - Funding data includes both direct contributions and matching pools
                """,
                "Further Resources": """
                - [Getting Started with Pyoso](https://docs.opensource.observer/docs/get-started/python)
                - [Gitcoin Analysis Repository](https://github.com/opensource-observer/insights/tree/main/analysis/gitcoin)
                - [Marimo Documentation](https://docs.marimo.io/)
                """
            })
        })    
    ])
    return


@app.cell
def import_libraries():
    import numpy as np
    import pandas as pd
    import plotly.express as px
    import plotly.graph_objects as go
    return go, pd


@app.cell
def configuration_settings():
    # Color constants
    PURPLE = '#6935FF'
    GREEN = '#3A4934'
    WHITE = 'WHITE'
    CYAN = '#A3E5E7'

    # Date constants
    START = '2018Q1'
    END = '2023Q4'

    # Data source
    DATA_URL_BASE = "https://raw.githubusercontent.com/opensource-observer/insights/refs/heads/main/analysis/gitcoin/data"

    return CYAN, DATA_URL_BASE, END, GREEN, START, WHITE


@app.cell
def load_project_names(DATA_URL_BASE, pd):
    project_names = pd.read_json(f"{DATA_URL_BASE}/gitcoin-project-names.json").set_index('slug')['name'].to_dict()
    return (project_names,)


@app.cell
def load_grants_data(DATA_URL_BASE, pd):
    g = pd.read_csv(f"{DATA_URL_BASE}/csv/gitcoin_allo%2Bcgrants_all.csv", index_col=0)

    # load and arrange the funding round data
    g['quarter'] = pd.PeriodIndex(g.round_date, freq='Q')
    g['quarter'] = g['quarter'].apply(str)

    def name_round(rid, rname):
        if '0x' in rid:
            return rname
        else:
            return f"GR{rid}"
    g['round'] = g.apply(lambda x: name_round(x['round_id'], x['round_name']), axis=1)

    # manual updates to clean a few rounds that are on the edge of a quarter
    g.loc[g['round'] == 'GR2', 'quarter'] = '2019Q2'
    g.loc[g['round'] == 'GR4', 'quarter'] = '2019Q4'

    # rename allo grants
    g.loc[g['quarter'] == '2023Q1', 'round'] = 'Alpha'
    g.loc[g['quarter'] == '2023Q2', 'round'] = 'Beta'
    g.loc[g['quarter'] == '2023Q3', 'round'] = 'GG18'
    g.loc[g['quarter'] == '2023Q4', 'round'] = 'GG19'
    return (g,)


@app.cell
def display_overall_stats(g, headline_fig, mo):
    total_usd = g['total_usd'].sum()
    match_usd = g['match_usd'].sum()
    multiplier = total_usd / match_usd

    total_stat = mo.stat(
        label="Total Funding",
        value=f"${total_usd/1_000_000:.1f}M",
        bordered=True
    )

    matching_stat = mo.stat(
        label="Matching Pools",
        value=f"${match_usd/1_000_000:.1f}M",
        bordered=True
    )

    multiplier_stat = mo.stat(
        label="QF Multiplier",
        value=f"{multiplier:.2f}x",
        bordered=True
    )

    applications_stat = mo.stat(
        label="Applications",
        value=f"{len(g):,}",
        bordered=True
    )

    projects_stat = mo.stat(
        label="Unique Projects",
        value=f"{len(g['grant_address'].unique()):,}",
        bordered=True
    )

    mo.vstack([
        mo.md("## Grants = Growth"),
        mo.hstack([total_stat, matching_stat, multiplier_stat, applications_stat, projects_stat], widths="equal", gap=1),
        headline_fig
    ])
    return (multiplier,)


@app.cell
def generate_funding_by_round_chart(GREEN, WHITE, g, go, mo):
    _data = g.groupby(['quarter', 'round'])['total_usd'].sum().iloc[:19].reset_index().set_index('round')

    _fig = go.Figure()
    _fig.add_trace(go.Bar(
        x=_data.index,
        y=_data['total_usd'],
        marker_color=GREEN,
        text=[f"${v/1_000_000:.1f}M" for v in _data['total_usd']],
        textposition='outside',
        hovertemplate='<b>%{x}</b><br>$%{y:,.0f}<extra></extra>'
    ))

    _fig.update_layout(
        title=dict(
            text='<b>Amount raised per round (Gitcoin Grants program)</b>',
            x=0,
            xanchor='left'
        ),
        paper_bgcolor=WHITE,
        plot_bgcolor=WHITE,
        font=dict(family="monospace", size=12, color=GREEN),
        height=400,
        margin=dict(t=50, l=50, r=20, b=50),
        showlegend=False,
        xaxis=dict(
            title='',
            showgrid=False,
            linecolor=GREEN,
            tickangle=0
        ),
        yaxis=dict(
            title='',
            showgrid=True,
            gridcolor='#E0E0E0',
            linecolor=GREEN,
            tickformat='$,.0f'
        )
    )

    mo.ui.plotly(_fig)
    return


@app.cell
def generate_phase_charts(GREEN, WHITE, g, go, mo):
    def phase_chart(dataframe, title_suffix=""):
        dff = dataframe[['project_name', 'amount_usd', 'match_usd', 'total_usd', 'round']].dropna().sort_values(by='total_usd', ascending=False)
        n = len(dff['total_usd'])
        total = dff['total_usd'].sum() / 1000000
        max_y = dff['total_usd'].iloc[1:].max() if len(dff) > 1 else dff['total_usd'].max()
        qf = dff[dff['match_usd'] > 0]['match_usd'].sum()
        rf = dff[dff['match_usd'] > 0]['amount_usd'].sum()
        multiple = rf / qf if qf > 0 else 0
        round_names = sorted(dff['round'].unique())
        title = f'<b>Gitcoin Grants: {round_names[0]}-{round_names[-1]}</b>'
        subtitle = f'Total = ${total:.1f}M DAI, QF multiplier = {multiple:.2f}x'

        # Get top 10 projects
        short_tail = dff[dff['match_usd'] > 0].groupby('project_name')['total_usd'].sum().sort_values(ascending=False).head(10)
        top_projects_text = '<br>'.join(['<b>Top Projects:</b>'] + [f'• {p}' for p in short_tail.index.unique()])

        _fig = go.Figure()
        _fig.add_trace(go.Bar(
            x=list(range(len(dff))),
            y=dff['total_usd'] / 1000,
            marker_color=GREEN,
            hovertemplate='<b>Project %{x}</b><br>$%{y:.2f}K<extra></extra>',
            width=1
        ))

        _fig.update_layout(
            title=dict(
                text=f'{title}<br><sub>{subtitle}</sub>',
                x=0,
                xanchor='left'
            ),
            paper_bgcolor=WHITE,
            plot_bgcolor=WHITE,
            font=dict(family="monospace", size=12, color=GREEN),
            height=400,
            margin=dict(t=80, l=50, r=20, b=50),
            showlegend=False,
            xaxis=dict(
                title='Num project applications',
                showgrid=False,
                linecolor=GREEN,
                range=[0, n]
            ),
            yaxis=dict(
                title='Total funding per project (per round)',
                showgrid=True,
                gridcolor='#E0E0E0',
                linecolor=GREEN,
                tickformat='$,.0f',
                ticksuffix='K',
                range=[0, max_y / 1000]
            ),
            annotations=[
                dict(
                    x=n * 0.05,
                    y=max_y / 1000,
                    text=top_projects_text,
                    showarrow=False,
                    align='left',
                    xanchor='left',
                    yanchor='top',
                    font=dict(size=10)
                )
            ]
        )

        return _fig

    _fig1 = phase_chart(g[g['quarter'] < '2020Q1'])
    _fig2 = phase_chart(g[(g['quarter'] >= '2020Q1') & (g['quarter'] < '2021Q2')])
    _fig3 = phase_chart(g[(g['quarter'] >= '2021Q2') & (g['quarter'] < '2023Q1')])
    _fig4 = phase_chart(g[(g['quarter'] >= '2023Q1') & (g['quarter'] < '2024Q1')])

    mo.vstack([
        mo.md("## Four Phases of Gitcoin Grants"),
        mo.ui.plotly(_fig1),
        mo.ui.plotly(_fig2),
        mo.ui.plotly(_fig3),
        mo.ui.plotly(_fig4)
    ])
    return


@app.cell
def load_impact_data(DATA_URL_BASE, END, START, pd):
    # load and arrange the impact metrics
    impact = (
        pd.read_csv(f"{DATA_URL_BASE}/csv/gitcoin_active_devs_impact_by_quarter.csv", index_col=0)
        .set_index(['project_slug', 'quarter'])
        .join(
            pd.read_csv(f"{DATA_URL_BASE}/csv/gitcoin_contributor_impact_by_quarter.csv", index_col=0)
            .groupby(['project_slug', 'quarter'])
            ['from_name']
            .nunique()
            .rename('contributors')
        )
        .reset_index()
    )
    impact = impact[
        (impact['project_slug'] != 'gitcoin') 
        & (impact['quarter'] >= START) 
        & (impact['quarter'] <= END)
    ]

    # filter on the top 50 OSS projects
    top50_oss_slugs = (    
        impact
        .groupby('project_slug')
        ['contributors']
        .max()
        .sort_values()
        .tail(50)
        .index
        .to_list()
    )
    impact = impact[impact['project_slug'].isin(top50_oss_slugs)]

    return impact, top50_oss_slugs


@app.cell
def filter_grants_data(g, top50_oss_slugs):
    # filter on the relevant grants data
    grants = g.copy()
    grants = grants[['oso_slug', 'round_id', 'round_name', 'quarter', 'round', 'round_date', 'total_usd']]
    grants = grants[grants['oso_slug'].isin(top50_oss_slugs)]
    return (grants,)


@app.cell
def display_roi_metrics(grants, impact, mo, multiplier):
    oss_grants = grants['total_usd'].sum()
    oss_devs = impact[impact['quarter'] == '2023Q4']['full-time'].sum()
    roi = oss_devs / oss_grants * 1_000_000

    cum_grants_stat = mo.stat(
        label="Cumulative Grants to Top 50 OSS",
        value=f"${oss_grants/1_000_000:.1f}M",
        bordered=True
    )

    ft_devs_stat = mo.stat(
        label="Full-time Developers (2023Q4)",
        value=f"{int(oss_devs):,}",
        bordered=True
    )

    roi_stat = mo.stat(
        label="$1M in Grants → FT Devs",
        value=f"{roi:.1f}",
        bordered=True
    )

    roi_multiplier_stat = mo.stat(
        label="With Crowdfunding Multiplier",
        value=f"{roi*multiplier:.1f}",
        bordered=True,
        caption="Full-time developer equivalents"
    )

    mo.vstack([
        mo.md("## Return on Investment Analysis"),
        mo.hstack([cum_grants_stat, ft_devs_stat, roi_stat, roi_multiplier_stat], widths="equal", gap=1)
    ])
    return


@app.cell
def generate_contributors_chart(GREEN, WHITE, go, impact, mo, project_names):
    data = (
        impact.pivot_table(index='project_slug', columns='quarter', values='contributors')
        .iloc[:, -4:]
        .fillna(0)
        .mean(axis=1)
        .sort_values(ascending=False)
        .rename(index=project_names)
    )

    _fig = go.Figure()
    _fig.add_trace(go.Bar(
        x=data.index,
        y=data.values,
        marker_color=GREEN,
        hovertemplate='<b>%{x}</b><br>%{y:.1f} contributors<extra></extra>'
    ))

    _fig.update_layout(
        title=dict(
            text='<b>Avg quarterly contributors for the top 50 OSS projects on Gitcoin Grants in 2023</b>',
            x=0,
            xanchor='left'
        ),
        paper_bgcolor=WHITE,
        plot_bgcolor=WHITE,
        font=dict(family="monospace", size=12, color=GREEN),
        height=500,
        margin=dict(t=50, l=50, r=20, b=150),
        showlegend=False,
        xaxis=dict(
            title='',
            showgrid=False,
            linecolor=GREEN,
            tickangle=-45
        ),
        yaxis=dict(
            title='',
            showgrid=True,
            gridcolor='#E0E0E0',
            linecolor=GREEN
        )
    )

    mo.ui.plotly(_fig)
    return


@app.cell
def prepare_quarterly_stats(grants, impact):
    grant_stats = grants.groupby(['quarter', 'round'])['total_usd'].sum()

    quarters = sorted(impact['quarter'].unique())
    quarter_mapping = dict(zip(quarters, range(len(quarters))))

    projects_first_rounds = (
        grants
        .groupby(['oso_slug'])
        ['quarter']
        .min()
        .reset_index()
        .groupby('quarter')
        ['oso_slug']
        .agg(lambda x: sorted(x))
    )
    ordered_projects_list = [p for lst in projects_first_rounds for p in lst]

    return (
        grant_stats,
        ordered_projects_list,
        projects_first_rounds,
        quarter_mapping,
        quarters,
    )


@app.cell
def generate_grants_growth_chart(
    CYAN,
    END,
    GREEN,
    START,
    WHITE,
    go,
    grant_stats,
    grants,
    impact,
    mo,
    ordered_projects_list,
    project_names,
    projects_first_rounds,
    quarter_mapping,
    quarters,
):
    start_q, end_q = (quarter_mapping.get(START), quarter_mapping.get(END))

    # Prepare the three main vectors
    contributors_vector = impact.groupby('quarter')['contributors'].sum()
    parttime_vector = impact.groupby('quarter')['part-time'].sum()
    fulltime_vector = impact.groupby('quarter')['full-time'].sum()

    # Scale to show growth multiples
    contributors_scaled = contributors_vector / contributors_vector.iloc[0]
    parttime_scaled = parttime_vector / parttime_vector.iloc[0]
    fulltime_scaled = fulltime_vector / fulltime_vector.iloc[0]

    # Calculate CAGR for each metric
    contributors_cagr = round(((contributors_vector.iloc[-1] / contributors_vector.iloc[0]) ** (1 / len(contributors_vector)) - 1) * 100, 1)
    parttime_cagr = round(((parttime_vector.iloc[-1] / parttime_vector.iloc[0]) ** (1 / len(parttime_vector)) - 1) * 100, 1)
    fulltime_cagr = round(((fulltime_vector.iloc[-1] / fulltime_vector.iloc[0]) ** (1 / len(fulltime_vector)) - 1) * 100, 1)

    _fig = go.Figure()

    # Add the three main trend lines
    _fig.add_trace(go.Scatter(
        x=list(range(len(contributors_scaled))),
        y=contributors_scaled,
        mode='lines',
        name='Contributors',
        line=dict(color=CYAN, width=4),
        opacity=0.75,
        hovertemplate='<b>Contributors</b><br>%{y:.2f}x growth<extra></extra>'
    ))

    _fig.add_trace(go.Scatter(
        x=list(range(len(parttime_scaled))),
        y=parttime_scaled,
        mode='lines',
        name='Part-time developers',
        line=dict(color='#6935FF', width=4),
        opacity=0.75,
        hovertemplate='<b>Part-time developers</b><br>%{y:.2f}x growth<extra></extra>'
    ))

    _fig.add_trace(go.Scatter(
        x=list(range(len(fulltime_scaled))),
        y=fulltime_scaled,
        mode='lines',
        name='Full-time developers',
        line=dict(color=GREEN, width=4),
        opacity=0.75,
        hovertemplate='<b>Full-time developers</b><br>%{y:.2f}x growth<extra></extra>'
    ))

    # Add vertical lines for funding rounds and annotations
    annotations = []
    shapes = []

    ymax = max(contributors_scaled.max(), parttime_scaled.max(), fulltime_scaled.max())
    ysub = -(ymax * 0.1)
    ysub_offset = ymax * 0.0225

    # Format helper functions
    amt_fmt = lambda a: '<$0.1M' if a < 100000 else f'${a / 1000000:.1f}M'
    amt_fmt_k = lambda a: '<$1K' if a < 1000 else f'${a / 1000:.0f}K'

    # Add legend labels at the end of lines
    annotations.append(dict(
        x=end_q + 0.25,
        y=contributors_scaled.iloc[-1],
        text=f"Contributors<br>+{contributors_cagr}% growth (QoQ)<br>({int(contributors_vector.iloc[0]):,} → {int(contributors_vector.iloc[-1]):,})",
        showarrow=False,
        xanchor='left',
        yanchor='middle',
        font=dict(color=GREEN, size=10),
        bgcolor=WHITE
    ))

    annotations.append(dict(
        x=end_q + 0.25,
        y=parttime_scaled.iloc[-1],
        text=f"Part-time developers<br>+{parttime_cagr}% growth (QoQ)<br>({int(parttime_vector.iloc[0]):,} → {int(parttime_vector.iloc[-1]):,})",
        showarrow=False,
        xanchor='left',
        yanchor='middle',
        font=dict(color=GREEN, size=10),
        bgcolor=WHITE
    ))

    annotations.append(dict(
        x=end_q + 0.25,
        y=fulltime_scaled.iloc[-1],
        text=f"Full-time developers<br>+{fulltime_cagr}% growth (QoQ)<br>({int(fulltime_vector.iloc[0]):,} → {int(fulltime_vector.iloc[-1]):,})",
        showarrow=False,
        xanchor='left',
        yanchor='middle',
        font=dict(color=GREEN, size=10),
        bgcolor=WHITE
    ))

    # Add funding round annotations
    annotations.append(dict(
        x=-0.25,
        y=ysub / 2,
        text='<b>Funding to top<br>50 OSS projects<br>by grants round</b>',
        showarrow=False,
        xanchor='left',
        yanchor='middle',
        font=dict(color=GREEN, size=9)
    ))

    for i, ((quarter, round_name), amount) in enumerate(grant_stats.items()):
        x = quarter_mapping.get(quarter)
        if not x:
            continue

        # Add vertical line
        shapes.append(dict(
            type='line',
            x0=x, x1=x,
            y0=1, y1=ymax * 0.95,
            line=dict(color=GREEN, width=0.5),
            opacity=0.5
        ))

        # Round name and amount
        amt = amt_fmt(amount)
        annotations.append(dict(
            x=x,
            y=ysub / 2,
            text=f'<b>{round_name}</b><br>{amt}',
            showarrow=False,
            xanchor='center',
            yanchor='middle',
            font=dict(color=GREEN, size=9)
        ))

        # Project-level funding details
        first_round_projects = projects_first_rounds.get(quarter)
        for y_idx, project_slug in enumerate(ordered_projects_list):
            filtered_grants = grants[grants['quarter'] == quarter]
            included_projects = filtered_grants['oso_slug'].to_list()
            if project_slug not in included_projects:
                continue

            # Show project name if it's their first round
            if first_round_projects and project_slug in first_round_projects:
                annotations.append(dict(
                    x=x - 0.25,
                    y=ysub - y_idx * ysub_offset,
                    text=f'{project_names.get(project_slug, project_slug)}',
                    showarrow=False,
                    xanchor='right',
                    yanchor='middle',
                    font=dict(color=GREEN, size=8)
                ))

            # Show funding amount
            result = filtered_grants[filtered_grants['oso_slug'] == project_slug]['total_usd'].sum()
            label = amt_fmt_k(result)
            annotations.append(dict(
                x=x,
                y=ysub - y_idx * ysub_offset,
                text=label,
                showarrow=False,
                xanchor='center',
                yanchor='middle',
                font=dict(color='grey', size=8),
                opacity=0.5
            ))

    # Add total funding column
    annotations.append(dict(
        x=end_q + 2,
        y=ysub / 2,
        text=f'<b>Total</b><br>{amt_fmt(grant_stats.sum())}',
        showarrow=False,
        xanchor='right',
        yanchor='middle',
        font=dict(color=GREEN, size=9)
    ))

    for y_idx, project_slug in enumerate(ordered_projects_list):
        funding = grants[grants['oso_slug'] == project_slug]['total_usd'].sum()
        annotations.append(dict(
            x=end_q + 2,
            y=ysub - y_idx * ysub_offset,
            text=amt_fmt_k(funding),
            showarrow=False,
            xanchor='right',
            yanchor='middle',
            font=dict(color=GREEN, size=8)
        ))


    _fig.update_layout(
        title=dict(
            text='<b>Quarterly developer metrics for the top 50 OSS projects on Gitcoin Grants since 2018</b>',
            x=0,
            xanchor='left',
            y=0.98
        ),
        paper_bgcolor=WHITE,
        plot_bgcolor=WHITE,
        font=dict(family="monospace", size=12, color=GREEN),
        height=1500,
        margin=dict(t=100, l=50, r=200, b=200),
        showlegend=False,
        xaxis=dict(
            title='',
            showgrid=False,
            linecolor=GREEN,
            range=[start_q, end_q + 2.5],
            tickmode='array',
            tickvals=list(range(0, len(quarters), 4)),
            ticktext=[str(x) for x in range(2018, 2024)]
        ),
        yaxis=dict(
            title='',
            showgrid=True,
            gridcolor='#E0E0E0',
            linecolor=GREEN,
            tickmode='array',
            tickvals=[2, 5, 10, 15, 20],
            ticktext=['2x', '5x', '10x', '15x', '20x']
        ),
        annotations=annotations,
        shapes=shapes,
        hovermode='x unified'
    )
    headline_fig = mo.ui.plotly(_fig)
    return (headline_fig,)


@app.cell
def _():
    return


if __name__ == "__main__":
    app.run()
