import marimo

__generated_with = "0.15.3"
app = marimo.App(width="medium")


@app.cell
def setup_pyoso():
    # This code sets up pyoso to be used as a database provider for this notebook
    # This code is autogenerated. Modification could lead to unexpected results :)
    import marimo as mo
    from pyoso import Client
    client = Client()
    try:
        pyoso_db_conn = client.dbapi_connection()    
    except Exception as e:
        pyoso_db_conn = None
    return client, mo


@app.cell
def about_app(mo):
    mo.vstack([
        mo.md("""
        # Developer Ecosystem Benchmarking
        <small>Author: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">OSO Team</span> Â· Last Updated: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">2025-09-15</span></small>
        """),
        mo.md("""
        This dashboard compares weekly GitHub metrics for selected ecosystems to visualize development activity trends over time.
        """),
        mo.accordion({
            "<b>Click to see details on how app was made</b>": mo.accordion({
                "Methodology": """
                - Weekly GitHub metrics are compared between Ethereum and selected ecosystems
                - Metrics include commits, pull requests, stars, forks, contributors, and project velocity
                - Data is normalized to show relative growth patterns over time
                - Analysis focuses on developer activity and engagement trends
                """,
                "Data Sources": """
                - [OSO API](https://docs.opensource.observer/docs/get-started/python) - GitHub metrics data
                - [Electric Capital Crypto Ecosystems](https://github.com/electric-capital/crypto-ecosystems) - Ecosystem classifications
                """,
                "Further Resources": """
                - [Getting Started with Pyoso](https://docs.opensource.observer/docs/get-started/python)
                - [Using the Semantic Layer](https://docs.opensource.observer/docs/get-started/using-semantic-layer)
                - [Marimo Documentation](https://docs.marimo.io/)
                """
            })
        })    
    ])
    return


@app.cell
def import_libraries():
    import pandas as pd
    import plotly.express as px

    stringify = lambda arr: "'" + "','".join(arr) + "'"
    return pd, px


@app.cell
def configuration_settings(mo):
    ALL_ECOSYSTEMS = [
        'Ethereum',
        'EVM Compatible Layer 2s',
        'Ethereum L2s',
        'Solana',
        'Polygon',
        'Arbitrum',
        'Base',
        'Optimism'
    ]

    METRICS = sorted([
        'Commits',
        'Opened Pull Requests',
        'Merged Pull Requests',
        'Stars',
        'Forks',
        'Burstiness',
        'Contributors',
        'Repositories',
        'Project Velocity',
    ])

    ecosystem1_dropdown = mo.ui.dropdown(
        options=ALL_ECOSYSTEMS,
        label='Select first ecosystem',
        full_width=True,
        value='Ethereum'
    )

    ecosystem2_dropdown = mo.ui.dropdown(
        options=ALL_ECOSYSTEMS,
        label='Select second ecosystem',
        full_width=True,
        value='Solana'
    )

    metric_dropdown = mo.ui.dropdown(
        options=METRICS,
        label="Select a weekly GitHub metric",
        full_width=True,
        value='Project Velocity'
    )

    mo.vstack([
        mo.md("### Configuration"),
        mo.hstack([
            ecosystem1_dropdown,
            ecosystem2_dropdown,
            metric_dropdown
        ], widths="equal", gap=2)
    ])
    return ecosystem1_dropdown, ecosystem2_dropdown, metric_dropdown


@app.cell
def get_data(
    client,
    ecosystem1_dropdown,
    ecosystem2_dropdown,
    metric_dropdown,
):
    _query = f"""
    SELECT
      sample_date,
      projects_v1.display_name,
      amount
    FROM timeseries_metrics_by_project_v0
    JOIN projects_v1 USING project_id
    JOIN metrics_v0 USING metric_id
    WHERE
      metrics_v0.display_name = '{metric_dropdown.value}'
      AND metric_name LIKE '%_weekly'
      AND projects_v1.display_name IN ('{ecosystem1_dropdown.value}','{ecosystem2_dropdown.value}')
      AND project_source = 'CRYPTO_ECOSYSTEMS'
      AND project_namespace = 'eco'
    ORDER BY 1,2
    """

    df_metrics = client.to_pandas(_query)
    return (df_metrics,)


@app.cell
def generate_stats(df_metrics, ecosystem1_dropdown, ecosystem2_dropdown, mo):
    latest_date = df_metrics['sample_date'].max()
    latest_data = df_metrics[df_metrics['sample_date'] == latest_date]

    ecosystem1_latest = latest_data[latest_data['display_name'] == ecosystem1_dropdown.value]['amount'].iloc[0] if len(latest_data[latest_data['display_name'] == ecosystem1_dropdown.value]) > 0 else 0
    ecosystem2_latest = latest_data[latest_data['display_name'] == ecosystem2_dropdown.value]['amount'].iloc[0] if len(latest_data[latest_data['display_name'] == ecosystem2_dropdown.value]) > 0 else 0

    ecosystem1_stat = mo.stat(
        label=f"{ecosystem1_dropdown.value} (Latest)",
        bordered=True,
        value=f"{ecosystem1_latest:,.0f}",
    )

    ecosystem2_stat = mo.stat(
        label=f"{ecosystem2_dropdown.value} (Latest)",
        bordered=True,
        value=f"{ecosystem2_latest:,.0f}",
    )

    ratio_stat = mo.stat(
        label=f"Ratio ({ecosystem2_dropdown.value}/{ecosystem1_dropdown.value})",
        bordered=True,
        value=f"{ecosystem2_latest/ecosystem1_latest:.2f}" if ecosystem1_latest > 0 else "N/A",
    )

    mo.vstack([
        mo.md("## Key Metrics"),
        mo.hstack([ecosystem1_stat, ecosystem2_stat, ratio_stat], widths="equal", gap=1)
    ])
    return


@app.cell
def generate_plot_absolute(
    df_metrics,
    ecosystem1_dropdown,
    ecosystem2_dropdown,
    metric_dropdown,
    mo,
    px,
):
    def make_absolute_fig(dataframe, title=""):
        df_pivot = dataframe.pivot(index='sample_date', columns='display_name', values='amount')
        df_pivot = df_pivot.reset_index()

        fig = px.line(
            df_pivot, 
            x='sample_date', 
            y=df_pivot.columns[1:],
            title=f"<b>{title}</b>",
            color_discrete_map={ecosystem1_dropdown.value: 'black', ecosystem2_dropdown.value: '#AAA'}
        )

        fig.update_layout(
            paper_bgcolor="white",
            plot_bgcolor="white",
            font=dict(size=12, color="#111"),
            title=dict(text=title, x=0, xanchor="left"),
            margin=dict(t=50, l=20, r=20, b=20),
            legend_title="",
            hovermode="x"
        )
        fig.update_xaxes(
            showgrid=False,
            linecolor="#000",
            ticks="outside",
            tickformat="%b %Y",
            dtick="M6",
            tickangle=-45
        )
        fig.update_yaxes(
            showgrid=True,
            gridcolor="#DDD",
            linecolor="#000",
            ticks="outside",
            rangemode='tozero'
        )
        fig.update_traces(
            hovertemplate="%{y:,.0f}",
            selector=dict(mode='lines')
        )
        return fig

    _fig = make_absolute_fig(df_metrics, f"{metric_dropdown.value} Over Time")
    mo.vstack([
        mo.md("## Absolute Values"),
        mo.ui.plotly(_fig)
    ])
    return


@app.cell
def generate_plot_normalized(
    df_metrics,
    ecosystem1_dropdown,
    ecosystem2_dropdown,
    metric_dropdown,
    mo,
    pd,
    px,
):
    def make_normalized_fig(dataframe, title=""):
        df_pivot = dataframe.pivot(index='sample_date', columns='display_name', values='amount')
        df_pivot = df_pivot.reset_index()

        df_pivot_normalized = df_pivot.copy()
        for col in df_pivot_normalized.columns[1:]:
            # Calculate the average value for 2025
            avg_2025 = df_pivot_normalized[col][pd.to_datetime(df_pivot_normalized['sample_date']).dt.year == 2025].mean()
            # Use the average value as the initial value for normalization
            initial_value = avg_2025 if pd.notna(avg_2025) and avg_2025 != 0 else df_pivot_normalized[col].iloc[0]
            df_pivot_normalized[col] = df_pivot_normalized[col] / initial_value if initial_value != 0 else 0

        fig = px.line(
            df_pivot_normalized, 
            x='sample_date', 
            y=df_pivot_normalized.columns[1:],
            title=f"<b>{title}</b>",
            color_discrete_map={ecosystem1_dropdown.value: 'black', ecosystem2_dropdown.value: '#AAA'}
        )

        fig.update_layout(
            paper_bgcolor="white",
            plot_bgcolor="white",
            font=dict(size=12, color="#111"),
            title=dict(text=title, x=0, xanchor="left"),
            margin=dict(t=50, l=20, r=20, b=20),
            legend_title="",
            hovermode="x"
        )
        fig.update_xaxes(
            showgrid=False,
            linecolor="#000",
            ticks="outside",
            tickformat="%b %Y",
            dtick="M6",
            tickangle=-45
        )
        fig.update_yaxes(
            showgrid=True,
            gridcolor="#DDD",
            linecolor="#000",
            ticks="outside",
            rangemode='tozero',
            title_text="Normalized Value"
        )
        fig.update_traces(
            hovertemplate="%{y:.2f}",
            selector=dict(mode='lines')
        )
        return fig

    _fig = make_normalized_fig(df_metrics, f"Normalized {metric_dropdown.value} Over Time (Avg 2025 = 1)")
    mo.vstack([
        mo.md("## Normalized Values"),
        mo.ui.plotly(_fig)
    ])
    return


@app.cell
def _():
    return


if __name__ == "__main__":
    app.run()
