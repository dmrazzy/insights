import marimo

__generated_with = "0.15.3"
app = marimo.App(width="full")


@app.cell
def setup_pyoso():
    # This code sets up pyoso to be used as a database provider for this notebook
    # This code is autogenerated. Modification could lead to unexpected results :)
    import marimo as mo
    from pyoso import Client
    client = Client()
    try:
        pyoso_db_conn = client.dbapi_connection()    
    except Exception as e:
        pyoso_db_conn = None
    return client, mo


@app.cell
def about_app(mo):
    mo.vstack([
        mo.md("""
        # Retro Funding S8: Onchain Builders
        <small>Author: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">OSO Team</span> Â· Last Updated: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">2025-09-21</span></small>
        """),
        mo.md("""
        An interactive dashboard for analyzing onchain builder activity and eligibility for Retrofunding S8.
        Track transaction counts, active days, and project metrics across different measurement periods.
        """),
        mo.accordion({
            "<b>Click to see details on how app was made</b>": mo.accordion({
            "Methodology": """
            - Projects are filtered by measurement period (M1-M7)
            - Eligibility based on transaction count and active days criteria
            - Flagged projects are excluded from eligibility calculations
            - Metrics tracked include transaction volume, active days, and chain-specific activity
            """,
            "Data Sources": """
            - [Superchain S8 Onchain Builder Eligibility](https://docs.opensource.observer/docs/get-started/python)
            - [Superchain S8 Onchain Metrics](https://docs.opensource.observer/docs/get-started/using-semantic-layer)
            - Project registries and collection data
            """,
            "Further Resources": """
            - [Getting Started with Pyoso](https://docs.opensource.observer/docs/get-started/python)
            - [Using the Semantic Layer](https://docs.opensource.observer/docs/get-started/using-semantic-layer)
            - [Marimo Documentation](https://docs.marimo.io/)
            """
        })
        })    
    ])
    return


@app.cell
def configuration_settings(mo):
    LATEST_PERIOD = 7

    get_period, set_period = mo.state(LATEST_PERIOD)

    period_buttons = {}
    for _period_num in range(1, LATEST_PERIOD + 1):
        def make_button(period_num):
            def handle_click(v):
                set_period(period_num)
                return v

            return mo.ui.button(
                label=f"M{period_num}",
                on_click=handle_click,
            )

        period_buttons[_period_num] = make_button(_period_num)

    mo.vstack([
        mo.hstack(
            [mo.md("**Measurement Period**")],
            justify="end",
        ),
        mo.hstack(
            [period_buttons[i] for i in range(1, LATEST_PERIOD + 1)],
            justify="end", 
            gap=0.5
        ),
    ])
    return LATEST_PERIOD, get_period


@app.cell
def _(get_period):
    THIS_PERIOD_NUM = get_period()
    THIS_PERIOD = f'M{THIS_PERIOD_NUM}'
    THIS_PERIOD_DATE = f'2025-{THIS_PERIOD_NUM+1}-01' # M1 = Feb (2), M2 = Mar (3)
    LAST_PERIOD_DATE = f'2025-{THIS_PERIOD_NUM}-01'   # The month before the current period
    END_DATE = f'2025-{THIS_PERIOD_NUM+2}-01'         # The month after the current period
    START_DATE = '2024-11-01'                     # Arbitrary start date for timeseries graphs

    FLAG_LIST = [
        '0xaa1b878800206da24ee7297fb202ef98a6af0fb3ec298a65ba6b675cb4f4144b', # Test Project
        '0x482720e73e91229b5f7d5e2d80a54eb8a722309c26dba03355359788b18f4373', # M4 RubyScore (manufactured activity)
        '0x03f730811b2a61aa1e8f7bdb6676e4027ed2b8f10bb731789a5d10e5ddc1352c', # M6 Onchain Heritage (manufactured activity)
        '0x076a2b1418a515ff8c5bb11beed5630cc6fe7f65fd8d42d4403c4364514f2a30', # M6 BAG Guild Dapp (manufactured activity)
    ]
    return END_DATE, FLAG_LIST, LAST_PERIOD_DATE, THIS_PERIOD_DATE


@app.cell
def project_metrics_section_header(mo):
    mo.vstack([
        mo.md("---"),
        mo.md("## Project Metrics"),
        mo.md("Month-over-month comparison for eligible projects")
    ])
    return


@app.cell
def chain_filter_configuration(df_metrics, mo):
    # Get unique chains from metrics data
    available_chains = sorted(df_metrics['chain'].unique().tolist()) if len(df_metrics) > 0 else ['ethereum', 'optimism', 'arbitrum']

    chain_filter = mo.ui.multiselect(
        options=available_chains,
        value=available_chains,  # Select all by default
        label="Filter by Chain"
    )

    mo.vstack([
        mo.md("### Chain Filter"),
        chain_filter
    ])
    return (chain_filter,)


@app.cell
def get_project_metrics_data(
    END_DATE,
    LAST_PERIOD_DATE,
    LATEST_PERIOD,
    client,
):
    metrics_query = f"""
        SELECT
            m.project_id,
            p.display_name,
            pbc.project_name,
            m.chain,
            m.metric_name,
            DATE_FORMAT(m.sample_date, '%Y-%m-%d') AS sample_date,
            DATE_FORMAT(m.sample_date, '%b %Y') AS measurement_period,
            m.amount
        FROM int_superchain_s8_onchain_metrics_by_project AS m
        JOIN projects_by_collection_v1 AS pbc ON m.project_id = pbc.project_id
        JOIN projects_v1 AS p ON pbc.project_id = p.project_id
        WHERE
            pbc.collection_name = '8-{LATEST_PERIOD}'
            AND m.sample_date >= DATE ('{LAST_PERIOD_DATE}')
            AND m.sample_date < DATE '{END_DATE}'
    """

    df_metrics = client.to_pandas(metrics_query)
    return (df_metrics,)


@app.cell
def show_project_metrics_data(chain_filter, df_metrics, df_projects, mo):
    # Filter metrics by selected chains
    _filtered_metrics = df_metrics[df_metrics['chain'].isin(chain_filter.value)]

    # Get only eligible projects
    _eligible_project_ids = df_projects[df_projects['is_eligible']]['project_id'].tolist()
    _eligible_metrics = _filtered_metrics[_filtered_metrics['project_id'].isin(_eligible_project_ids)]

    # Pivot to get current vs previous month data
    _metrics_pivot = _eligible_metrics.pivot_table(
        index=['project_id', 'display_name'],
        columns=['metric_name', 'measurement_period'],
        values='amount',
        aggfunc='sum',
        fill_value=0
    ).reset_index()

    # Flatten column names with proper formatting
    _formatted_columns = ['Project ID', 'Display Name']
    for metric, period in _metrics_pivot.columns[2:]:
        # Convert metric to title case and put period in parentheses
        _formatted_name = f"{metric.replace('_', ' ').title()} ({period})"
        _formatted_columns.append(_formatted_name)

    _metrics_pivot.columns = _formatted_columns

    # Create format mapping for numeric columns
    _numeric_cols = [col for col in _metrics_pivot.columns if col not in ['Project ID', 'Display Name']]
    _format_mapping = {col: '{:,.0f}' for col in _numeric_cols}

    _metrics_pivot = _metrics_pivot.drop(columns='Project ID')

    mo.vstack([
        mo.md("### Project Metrics Comparison"),
        mo.ui.table(
            _metrics_pivot.reset_index(drop=True),
            selection=None,
            show_column_summaries=False,
            show_data_types=False,
            page_size=25,
            format_mapping=_format_mapping,
            freeze_columns_left=['Display Name']
        )
    ])
    return


@app.cell
def eligibility_section_header(mo):
    mo.vstack([
        mo.md("---"),
        mo.md("## Project Eligibility Table"),
        mo.md("All projects with eligibility status and activity metrics")
    ])
    return


@app.cell
def get_project_data(FLAG_LIST, LATEST_PERIOD, THIS_PERIOD_DATE, client):
    project_query = f"""
        SELECT
            p.project_id,
            p.project_name,
            p.display_name,
            e.transaction_count,
            e.active_days,
            (e.meets_all_criteria AND NOT (p.project_name IN ({stringify(FLAG_LIST)}))) AS is_eligible
        FROM int_superchain_s8_onchain_builder_eligibility AS e
        JOIN projects_v1 AS p ON e.project_id = p.project_id
        JOIN projects_by_collection_v1 AS pbc ON p.project_id = pbc.project_id
        WHERE
            pbc.collection_name = '8-{LATEST_PERIOD}'
            AND e.sample_date = DATE '{THIS_PERIOD_DATE}'
        ORDER BY e.transaction_count DESC
    """

    df_projects = client.to_pandas(project_query)
    return (df_projects,)


@app.cell
def show_project_eligibility_stats(df_projects, mo):
    total_projects = mo.stat(
        label="Total Projects",
        bordered=True,
        value=f"{len(df_projects):,.0f}",
    )

    eligible_projects = mo.stat(
        label="Eligible Projects",
        bordered=True,
        value=f"{df_projects['is_eligible'].sum():,.0f}",
    )

    # Calculate projects below minimums (assuming some threshold - you may need to adjust these)
    transaction_threshold = 10  # Adjust this threshold as needed
    active_days_threshold = 5   # Adjust this threshold as needed

    below_transaction_min = mo.stat(
        label="Below Transaction Min",
        bordered=True,
        value=f"{(df_projects['transaction_count'] < transaction_threshold).sum():,.0f}",
    )

    below_active_days_min = mo.stat(
        label="Below Active Day Min",
        bordered=True,
        value=f"{(df_projects['active_days'] < active_days_threshold).sum():,.0f}",
    )

    mo.hstack([
        total_projects,
        eligible_projects,
        below_transaction_min,
        below_active_days_min
    ], widths="equal", gap=1)
    return


@app.cell
def show_project_eligibility_table(df_projects, mo):
    # Prepare table data
    _table_data = df_projects.copy()
    _table_data['is_eligible'] = _table_data['is_eligible'].map({True: 'Yes', False: 'No'})
    _table_data = _table_data.drop(columns=['project_id'])
    _table_data = _table_data.rename(columns={
        'project_name': 'Atlas ID',
        'display_name': 'Project Name',
        'transaction_count': 'Transaction Count',
        'active_days': 'Active Days',
        'is_eligible': 'Eligible'
    })

    mo.vstack([
        mo.md("### Project Eligibility Status"),
        mo.ui.table(
            _table_data.reset_index(drop=True),
            selection=None,
            show_column_summaries=False,
            show_data_types=False,
            page_size=25,
            format_mapping={
                'Transaction Count': '{:,.0f}',
                'Active Days': '{:,.0f}'
            }
        )
    ])
    return


@app.function
def stringify(flag_list):
    return "'" + "', '".join(flag_list) + "'"


@app.cell
def import_libraries():
    import datetime
    import pandas as pd
    import plotly.express as px
    return


if __name__ == "__main__":
    app.run()
