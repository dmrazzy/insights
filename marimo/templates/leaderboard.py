import marimo

__generated_with = "0.15.3"
app = marimo.App(width="full")


@app.cell
def setup_pyoso():
    # This code sets up pyoso to be used as a database provider for this notebook
    # This code is autogenerated. Modification could lead to unexpected results :)
    import marimo as mo
    from pyoso import Client
    client = Client()
    try:
        pyoso_db_conn = client.dbapi_connection()    
    except Exception as e:
        pyoso_db_conn = None
    return (mo,)


@app.cell
def about_app(mo):
    mo.vstack([
        mo.md("""
        # Leaderboard Template
        <small>Author: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">OSO Team</span> · Last Updated: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">2025-09-15</span></small>
        """),
        mo.md("""
        An interactive dashboard for analyzing movie data with filtering, statistics, and visualizations.
        Note: this is a template for creating leaderboard-style dashboards.
        """),
        mo.accordion({
            "<b>Click to see details on how app was made</b>": mo.accordion({
            "Methodology": """
            - Movies are filtered by release date range
            - Statistics compare current period to previous period of equal duration
            - Scatter plot shows relationship between production budget and IMDB rating
            - Data includes major genres for categorical analysis
            """,
            "Data Sources": """
            - [Vega Datasets - Movies](https://vega.github.io/vega-datasets/data/movies.json)
            - Sample movie data with budget, gross, ratings, and genre information
            """,
            "Further Resources": """
            - [Original version of this dashboard](https://marimo.io/@public/movies)
            - [Marimo Documentation](https://docs.marimo.io/)
            """
        })
        })    
    ])
    return


@app.cell
def _(
    button_00s,
    button_10s,
    button_80s,
    button_90s,
    end_date_input,
    mo,
    start_date_input,
):
    _range = mo.md(f"{start_date_input} – {end_date_input}")

    mo.hstack(
        [
            _range,
            mo.hstack(
                [
                    mo.md("Quick decade:"),
                    button_80s,
                    button_90s,
                    button_00s,
                    button_10s,
                ],
                justify="end",
                align="end",
                gap=0.5,
            )
        ]
    )
    return


@app.cell
def _(mo, pd, set_end_date, set_start_date):
    def decade_button(decade):
        s = pd.to_datetime(f"{decade}-01-01")
        e = pd.to_datetime(f"{decade + 10}-01-01")

        def handle_click(v):
            set_start_date(s)
            set_end_date(e)
            return 1

        return mo.ui.button(
            label=f"{decade}s",
            on_click=handle_click,
        )


    button_80s = decade_button(1980)
    button_90s = decade_button(1990)
    button_00s = decade_button(2000)
    button_10s = decade_button(2010)
    return button_00s, button_10s, button_80s, button_90s


@app.cell
def _(mo, previous_end_date, previous_start_date):
    mo.md(f"""> Compared to: {previous_start_date.strftime("%Y-%m-%d")} - {previous_end_date.strftime("%Y-%m-%d")}""")
    return


@app.cell
def _(get_end_date, get_start_date, mo, pd, set_end_date, set_start_date):
    start_date_input = mo.ui.date(
        label="Start Date",
        value=get_start_date().strftime("%Y-%m-%d"),
        on_change=lambda x: set_start_date(pd.to_datetime(x)),
    )
    end_date_input = mo.ui.date(
        label="End Date",
        value=get_end_date().strftime("%Y-%m-%d"),
        on_change=lambda x: set_end_date(pd.to_datetime(x)),
    )
    return end_date_input, start_date_input


@app.cell
def _(
    filtered_movies,
    get_average_budget,
    get_average_gross,
    get_average_rating,
    get_average_runtime,
    mo,
    previous_movies,
):
    mo.stop(len(filtered_movies) == 0, "")

    previous_total_movies_count = len(previous_movies)
    previous_total_movies_change_rate = (
        (len(filtered_movies) - previous_total_movies_count)
        / previous_total_movies_count
        if previous_total_movies_count > 0
        else 0
    )
    total_movies = mo.stat(
        label="Total Movies",
        bordered=True,
        caption=f"{previous_total_movies_change_rate:.0%}",
        direction="increase"
        if previous_total_movies_change_rate > 0
        else "decrease",
        value=f"{len(filtered_movies):,.0f}",
    )

    gross_current, gross_previous, gross_rate = get_average_gross(
        filtered_movies, previous_movies
    )
    gross_stat = mo.stat(
        label="Average Gross",
        bordered=True,
        caption=f"{gross_rate:.0%}",
        direction="increase" if gross_rate > 0 else "decrease",
        value=f"${gross_current:,.0f}",
    )

    budget_current, budget_previous, budget_rate = get_average_budget(
        filtered_movies, previous_movies
    )
    budget_stat = mo.stat(
        label="Average Budget",
        bordered=True,
        caption=f"{budget_rate:.0%}",
        direction="increase" if budget_rate > 0 else "decrease",
        value=f"${budget_current:,.0f}",
    )

    runtime_current, runtime_previous, runtime_rate = get_average_runtime(
        filtered_movies, previous_movies
    )
    runtime_stat = mo.stat(
        label="Average Runtime",
        bordered=True,
        caption=f"{runtime_rate:.0%}",
        direction="increase" if runtime_rate > 0 else "decrease",
        value=f"{runtime_current:,.0f} min",
    )

    rating_current, rating_previous, rating_rate = get_average_rating(
        filtered_movies, previous_movies
    )
    average_rating = mo.stat(
        label="Average Rating",
        bordered=True,
        caption=f"{rating_rate:.0%}",
        direction="increase" if rating_rate > 0 else "decrease",
        value=f"{rating_current:.1f}",
    )

    mo.hstack(
        [total_movies, gross_stat, budget_stat, runtime_stat, average_rating],
        widths="equal",
        gap=1,
    )
    return


@app.cell
def _(filtered_movies, mo):
    mo.ui.table(
        filtered_movies.reset_index(drop=True),
        selection=None,
        show_column_summaries=False,
        show_data_types=False,
        page_size=50
    )
    return


@app.cell
def _(filtered_movies, mo, pd, px):
    def make_fig(dataframe, title=""):
        _df = dataframe.assign(
            Production_Budget_M=lambda d: pd.to_numeric(d["Production_Budget"], errors="coerce")/1e6
        )

        fig = px.scatter(
            _df,
            x="Production_Budget_M",
            y="IMDB_Rating",
            color="Major_Genre",
            hover_data=["Title","Major_Genre"],
            title=f"<b>{title}</b>"
        )

        fig.update_layout(
            paper_bgcolor="white",
            plot_bgcolor="white",
            font=dict(size=12, color="#111"),
            title=dict(text=title, x=0, xanchor="left"),
            margin=dict(t=50, l=20, r=20, b=20),
            legend_title="Major Genre",
            hovermode="closest"
        )

        fig.update_xaxes(
            title="Production Budget (Millions $)",
            showgrid=False,
            linecolor="#000",
            ticks="outside",
            tickprefix="$",
            ticksuffix="M",
            tickformat=",.0f"
        )

        fig.update_yaxes(
            title="IMDB Rating",
            showgrid=True,
            gridcolor="#DDD",
            linecolor="#000",
            ticks="outside"
        )

        fig.update_traces(
            hovertemplate="<b>%{customdata[0]}</b><br>"
                          "Genre: %{customdata[1]}<br>"
                          "Budget: $%{x:.0f}M<br>"
                          "IMDB: %{y:.1f}<br>"
        )

        return fig

    _fig = make_fig(filtered_movies, "IMDB Rating vs. Production Budget")
    mo.ui.plotly(_fig)
    return


@app.cell
def _(datetime):
    def get_average_budget(df, previous):
        current = df["US_Gross"].mean()
        previous = previous["US_Gross"].mean()
        rate = (current - previous) / previous
        return (current, previous, rate)


    def get_average_gross(df, previous):
        current = df["Worldwide_Gross"].mean()
        previous = previous["Worldwide_Gross"].mean()
        rate = (current - previous) / previous
        return (current, previous, rate)


    def get_average_runtime(df, previous):
        current = df["Running_Time_min"].mean()
        previous = previous["Running_Time_min"].mean()
        rate = (current - previous) / previous
        return (current, previous, rate)


    def get_average_rating(df, previous):
        current = df["IMDB_Rating"].mean()
        previous = previous["IMDB_Rating"].mean()
        rate = (current - previous) / previous
        return (current, previous, rate)


    def get_previous_date_range(start_date, end_date):
        delta = end_date - start_date
        return (
            (start_date - datetime.timedelta(days=delta.days)),
            (end_date - datetime.timedelta(days=delta.days)),
        )


    def format_date(date):
        return date.strftime("%Y-%m-%d")
    return (
        get_average_budget,
        get_average_gross,
        get_average_rating,
        get_average_runtime,
        get_previous_date_range,
    )


@app.cell
def _():
    import datetime
    import pandas as pd
    import plotly.express as px
    import vega_datasets as data
    return data, datetime, pd, px


@app.cell
def _(data, pd):
    movies = data.data.movies()

    # convert to date
    movies["Release_Date"] = pd.to_datetime(movies["Release_Date"])
    return (movies,)


@app.cell
def _(mo, pd):
    min = "2010-01-01"
    max = "2021-01-01"
    get_start_date, set_start_date = mo.state(pd.to_datetime(min))
    get_end_date, set_end_date = mo.state(pd.to_datetime(max))
    return get_end_date, get_start_date, set_end_date, set_start_date


@app.cell
def _(end_date_input, get_previous_date_range, movies, pd, start_date_input):
    start = pd.to_datetime(start_date_input.value)
    end = pd.to_datetime(end_date_input.value)
    filtered_movies = movies[
        (movies["Release_Date"] >= start) & (movies["Release_Date"] <= end)
    ]
    try:
        previous_start_date, previous_end_date = get_previous_date_range(
            start, end
        )
        previous_movies = movies[
            (movies["Release_Date"] >= previous_start_date)
            & (movies["Release_Date"] <= previous_end_date)
        ]
    except:
        previous_start_date = start
        previous_end_date = end
        previous_movies = filtered_movies
    return (
        filtered_movies,
        previous_end_date,
        previous_movies,
        previous_start_date,
    )


@app.cell
def _():
    return


if __name__ == "__main__":
    app.run()
