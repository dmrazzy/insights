import marimo

__generated_with = "0.15.3"
app = marimo.App(width="full")


@app.cell
def setup_pyoso():
    # This code sets up pyoso to be used as a database provider for this notebook
    # This code is autogenerated. Modification could lead to unexpected results :)
    import marimo as mo
    from pyoso import Client
    client = Client()
    try:
        pyoso_db_conn = client.dbapi_connection()    
    except Exception as e:
        pyoso_db_conn = None
    return client, mo


@app.cell
def about_app(mo):
    _author = 'OSO Team'
    _updated_at = '2025-09-15'
    mo.vstack([
        mo.md(f"""
        # Value Chain Template
        <small>Author: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">{_author}</span> Â· Last Updated: <span style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">{_updated_at}</span></small>
        """),
        mo.md("""
        This dashboard analyzes how gas fees flow through the Superchain ecosystem value chain, from applications to chains. The analysis shows the hierarchical distribution of gas consumption and tracks trends over time.
        Note: this version is intended to serve as a template for creating value chain analysis dashboards.
        """),
        mo.accordion({
            "<b>Click to see details on how app was made</b>": mo.accordion({
                "Methodology": """
                - Gas fees are analyzed at two levels: by chain and by project within each chain
                - Total amortized layer 2 gas fees are calculated over all time for each project
                - Daily gas fee trends are tracked to observe temporal patterns
                - Projects are filtered to only include those from the OSS Directory
                - Data is normalized and aggregated to show value chain relationships
                """,
                "Data Sources": """
                - [OSS Directory](https://github.com/opensource-observer/oss-directory)
                - [Pyoso API](https://docs.opensource.observer/docs/get-started/python)
                """,
                "Further Resources": """
                - [Getting Started with Pyoso](https://docs.opensource.observer/docs/get-started/python)
                - [Using the Semantic Layer](https://docs.opensource.observer/docs/get-started/using-semantic-layer)
                - [Marimo Documentation](https://docs.marimo.io/)
                """
            })
        })    
    ])
    return


@app.cell
def import_libraries():
    import pandas as pd
    import plotly.express as px
    import plotly.graph_objects as go
    return (px,)


@app.cell
def configuration_settings(mo):
    CHAINS = sorted([
        'OPTIMISM',       'ZORA',       'BASE',       'MODE',      'METAL',
             'BOB',       'LISK',       'MINT', 'POLYNOMIAL', 'WORLDCHAIN',
            'RACE',      'SHAPE',   'UNICHAIN',      'SWELL',    'SONEIUM',
             'INK',     'ARENAZ'
    ])

    chain_filter_input = mo.ui.multiselect(
        options=CHAINS,
        value=CHAINS,
        label="Filter by Chain",
        full_width=True
    )

    time_range_input = mo.ui.dropdown(
        options=["All Time", "YTD"],
        value="YTD",
        label="Time Range",
        full_width=True
    )

    mo.vstack([
        mo.md("### Configuration"),
        chain_filter_input,
        time_range_input
    ])
    return chain_filter_input, time_range_input


@app.cell
def get_data(client):
    _query_chains = """
    SELECT
      sample_date,
      chain,
      SUM(amount) AS gas_fees
    FROM int_chain_metrics AS t
    JOIN int_superchain_s8_chains AS c USING chain
    WHERE metric_name = 'FEES_PAID_ETH'
    GROUP BY 1,2
    ORDER BY 1,2
    """

    _query_projects = """
    WITH cte AS (
      SELECT DISTINCT
        DATE_TRUNC('YEAR', sample_date) AS sample_date,
        p.display_name AS project,
        regexp_extract(metric_name, '^(.*)_layer2_gas_fees_amortized_monthly', 1) AS chain,
        amount / 1e18 AS amount
      FROM timeseries_metrics_by_project_v0 AS tm
      JOIN projects_v1 p USING (project_id)
      JOIN metrics_v0 m USING (metric_id)
      WHERE metric_name LIKE '%_layer2_gas_fees_amortized_monthly'
        AND project_source = 'OSS_DIRECTORY'
      ORDER BY 3 DESC
    )
    SELECT
      sample_date,
      project,
      chain,
      amount AS gas_fees
    FROM cte
    JOIN int_superchain_s8_chains USING chain
    """

    df_chains_all = client.to_pandas(_query_chains)
    df_projects_all = client.to_pandas(_query_projects)
    return df_chains_all, df_projects_all


@app.cell
def filter_data(
    chain_filter_input,
    df_chains_all,
    df_projects_all,
    time_range_input,
):
    _ytd_date = df_projects_all['sample_date'].max()

    df_chains_filtered = df_chains_all[df_chains_all['chain'].isin(chain_filter_input.value)].copy()
    df_projects_filtered = df_projects_all[df_projects_all['chain'].isin(chain_filter_input.value)].copy()

    if time_range_input.value == "YTD":
        df_chains_filtered = df_chains_filtered[df_chains_filtered['sample_date'] >= _ytd_date]
        df_projects_filtered = df_projects_filtered[df_projects_filtered['sample_date'] == _ytd_date]

    _top_chains = list(df_chains_filtered.groupby('chain')['gas_fees'].sum().sort_values().tail(5).index)
    df_chains_filtered['chain'] = df_chains_filtered['chain'].apply(lambda chain: chain if chain in _top_chains else 'OTHER')

    df_projects_filtered = df_projects_filtered.groupby(['project', 'chain'], as_index=False)['gas_fees'].sum()
    df_chains_filtered = df_chains_filtered.groupby(['sample_date', 'chain'], as_index=False)['gas_fees'].sum()
    return (df_projects_filtered,)


@app.cell
def generate_plot_treemap(df_projects_filtered, mo, px):
    def make_treemap(dataframe, title=""):
        fig = px.treemap(
            data_frame=dataframe,
            path=[px.Constant("All"), 'chain', 'project'],
            values='gas_fees',
            title=f"<b>{title}</b>",
            color='gas_fees',
            color_continuous_scale='Reds',
            hover_data=['chain','project','gas_fees'] 
        )
        fig.update_layout(
            paper_bgcolor="white",
            plot_bgcolor="white",
            font=dict(size=12, color="#111"),
            title=dict(text=title, x=0, xanchor="left"),
            margin=dict(t=50, l=20, r=20, b=20),
            coloraxis_showscale=False,
            autosize=True
        )
        fig.update_traces(
            hovertemplate="<b>%{label}</b><br>Gas Fees: %{value:.2f}<extra></extra>"
        )

        return fig

    _fig = make_treemap(df_projects_filtered, "Gas Fees by Chain and Project")
    mo.ui.plotly(_fig)
    return


@app.cell
def _():
    return


if __name__ == "__main__":
    app.run()
